(function() {
  var Progress, PromiseBar, bar, pathval, stripAnsi,
    slice = [].slice;

  pathval = require("pathval");

  stripAnsi = require("strip-ansi");


  /*
  An individual item to be used with PromiseBar.
   */

  Progress = (function() {
    var get, set;

    get = function(props) {
      var getter, name, results;
      results = [];
      for (name in props) {
        getter = props[name];
        results.push(Progress.prototype.__defineGetter__(name, getter));
      }
      return results;
    };

    set = function(props) {
      var name, results, setter;
      results = [];
      for (name in props) {
        setter = props[name];
        results.push(Progress.prototype.__defineSetter__(name, setter));
      }
      return results;
    };


    /*
    @property {Number} the count of completed items
     */

    Progress.prototype.done = 0;


    /*
    @param {PromiseBar} bar the parent {PromiseBar}
    @param {Array<Any>} items the items that make up this progress bar.
    @param {Object} _opts options to configure the display of this progress bar.  See `opts` in {PromiseBar#all}.
     */

    function Progress(bar1, items1, _opts) {
      var item, j, len, ref;
      this.bar = bar1;
      this.items = items1;
      this._opts = _opts;
      ref = this.items;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        Promise.resolve(item).then((function(_this) {
          return function() {
            return _this.tick();
          };
        })(this));
        if (this.opt("flat")) {
          continue;
        }
        if ((item.PromiseBar != null) && item.PromiseBar instanceof Progress) {
          item.PromiseBar.parent = this;
          item.PromiseBar.unregister();
        }
      }
    }


    /*
    Called when one of the Promise items is resolved.
     */

    Progress.prototype.tick = function() {
      this.bar.clear();
      ++this.done;
      return this.bar.draw();
    };


    /*
    @property {Progress} set to another progress bar if this element appears under another element.
     */

    Progress.prototype.parent = null;


    /*
    @property {String} the proper number of spaces to indent progress bars that are in a hierarchy.
     */

    get({
      indent: function() {
        if (!this.parent) {
          return "";
        }
        return this.parent.indent + this.opt("indent");
      }

      /*
      @property {String} a label for this progress bar.
       */
    });

    get({
      rawLabel: function() {
        return stripAnsi(this.opt("label"));
      }

      /*
      @property {String} a label for this progress bar, optionally padded to make all labels the same length.
       */
    });

    get({
      label: function() {
        var label, max;
        label = this.opt("label");
        if (!(this.opt("pad") || this.opt("padDeep"))) {
          return label;
        }
        max = 0;
        if (this.opt("padDeep")) {
          max = this._deep_max_length;
        } else if (this.parent) {
          max = this.parent.maxLabelLength();
        } else {
          max = this.bar.maxLabelLength();
        }
        return label + " ".repeat(max - this.rawLabel.length - this.indent.length);
      }

      /*
      @property {Number} the total number of items.
       */
    });

    get({
      total: function() {
        return this.items.length;
      }

      /*
      @property {String} the percent of completed items.
       */
    });

    get({
      percent: function() {
        var val;
        val = this.total > 0 ? 100 * (this.done / this.total) : 0;
        return val.toPrecision(this.opt("percentLength"));
      }

      /*
      Find a configuration option by path.
      @param {String} k the path to a configuration option e.g. "categories[1].name"
      @return {Any} the value requested.
       */
    });

    Progress.prototype.opt = function(k) {
      if (pathval.hasProperty(this._opts, k)) {
        return pathval.getPathValue(this._opts, k);
      } else {
        return pathval.getPathValue(this.bar.conf, k);
      }
    };


    /*
    @property {Array<Progress>} the children progress bars that are descendants of this one.
     */

    get({
      children: function() {
        var bar, j, len, ref, results;
        ref = this.items;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          bar = ref[j];
          if (bar.PromiseBar && bar.PromiseBar instanceof Progress) {
            results.push(bar.PromiseBar);
          }
        }
        return results;
      }

      /*
      The number of lines needed to draw this progress bar.
      @return {Number}
       */
    });

    Progress.prototype.lines = function() {
      var bar, j, len, lines, ref;
      lines = 1;
      if (this.opt("flat")) {
        return lines;
      }
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        bar = ref[j];
        lines += bar.lines();
      }
      return lines;
    };


    /*
    Draws this progress bar to the console.
    @return {String} the formatted progress bar
     */

    Progress.prototype.progressBar = function() {
      var barFormat, barLength, fill, filled, fmt, fn, unfilled;
      fn = this.opt("format");
      fmt = fn.apply(this, []);
      if (fmt.indexOf(":bar") === -1) {
        return fmt;
      }
      barLength = process.stdout.columns - stripAnsi(fmt.replace(':bar', '')).length;
      filled = this.total > 0 ? Math.floor(barLength * (this.done / this.total)) : 0;
      fill = this.opt("filled")[0].repeat(filled);
      unfilled = this.opt("empty")[0].repeat(barLength - filled);
      barFormat = this.opt("barFormat");
      return console.log(fmt.replace(':bar', barFormat("" + fill + unfilled)));
    };


    /*
    Determine the maximum label length for progress bars.
    @param {Boolean} deep if `true`, check nested progress bars.  Defaults to `false`.
    @return {Number} the length of the longest label.
     */

    Progress.prototype.maxLabelLength = function(deep) {
      var item, j, len, max, ref;
      if (deep == null) {
        deep = false;
      }
      max = 0;
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (item.rawLabel) {
          max = Math.max(item.indent.length + item.rawLabel.length, max);
        }
        if (deep) {
          max = Math.max(item.maxLabelLength(true), max);
        }
      }
      return max;
    };


    /*
    Draws this progress bar, including any other progress bars that are under this one in the hierarchy.
    @param {Number} deep the maximum label length of any label
     */

    Progress.prototype.draw = function(deep) {
      var bar, j, len, ref, results;
      this._deep_max_length = deep;
      this.progressBar();
      if (this.opt("flat")) {
        return;
      }
      ref = this.children;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        bar = ref[j];
        results.push(bar.draw(deep));
      }
      return results;
    };

    Progress.prototype.unregister = function() {
      return this.bar.items.splice(this.bar.items.indexOf(this), 1);
    };

    return Progress;

  })();


  /*
  PromiseBar extends `Promise.all()` to display a progress bar representing the state of each item.
  
  Keeps progress bars under all other stdout messages.
  When drawing progress bars, a line is left under previous stdout messages, then progress bars are drawn.
  
  ```
  Listening to 8080.    # Previous stdout message
                         * Empty line
  Build: |----------|   # Progress bars
  ```
  
  The cursor is then moved to the empty line.
  When other messages are printed to stdout, they are written to the empty line, leaving the cursor on the first character
  of the progress bars.
  
  ```
  Listening to 8080.
  New client connection.
  Build: |----------|
  ```
  
  stdout writes are listened to.  {PromiseBar#clear} is called, which empties all lines of the progress bar.
  
  ```
  Listening to 8080.
  New client connection.
  
  ```
  
  The progress bars are then drawn again, with another empty line left for more `process.stdout` messages.
  
  ```
  Listening to 8080.
  New client connection.
  
  Build: |----------|
  ```
   */

  PromiseBar = (function() {
    PromiseBar.prototype.Progress = Progress;


    /*
    @property {Object} Default options to configure how progress bars are displayed.  See `opts` in  {PromiseBar#all} for
    the properties that can be set.
     */

    PromiseBar.prototype.conf = null;


    /*
    @property {Boolean} `true` if PromiseBar is in charge of stdout.
     */

    PromiseBar.prototype.enabled = false;


    /*
    @property {Boolean} `true` if PromiseBar has been stopped, and shouldn't be involved in output anymore.
     */

    PromiseBar.prototype.ended = false;


    /*
    @property {Boolean} `true` if PromiseBar is internally controlling `process.stdout`.
     */

    PromiseBar.prototype.processing = false;

    function PromiseBar() {
      this.conf = {
        flat: false,
        label: "",
        filled: "▇",
        empty: "-",
        indent: "  ",
        pad: true,
        padDeep: false,
        format: function() {
          return "" + this.indent + this.label + " [:bar] " + this.done + "/" + this.total + " " + this.percent + "%";
        },
        barFormat: function(bar) {
          return bar;
        },
        percentLength: 3
      };
    }


    /*
    `Promise.all` replacement.
    @param {Array<Any>} items an array of items, same as `Promise.all()`
    @param {Object} opts options to configure the display of the progress bar.  Defaults are set in {ProgressBar#opts}.
    @option opts {String} label text to include in the progress bar.
    @option opts {Boolean} flat if `true`, progress bars won't indent under each other.  Defaults to `false`.
    @option opts {Boolean} pad if `true`, labels on progress bars at the same depth are padded to be an equal length.
      Defaults to `true`.
    @option opts {Boolean} padDeep if `true`, all labels on progress bars are padded to be an equal length.  Defaults to
      `false`.
    @option opts {String} filled a character to use for the solid progress bar.  Defaults to `"▇"`.
    @option opts {String} empty a character to use for unfilled progress.  Defaults to `"-"`.
    @option opts {String} indent characters inserted before progress bars to show hierarchy.  Defaults to `"  "`.
    @option opts {Function} format a function that returns the string of the progress bar.  See variables in {Progress} to
      insert.  `":bar"` will be replaced with a progress bar filling the available space.
    @option opts {Function} barFormat a function that transforms the progress bar.  Could be used to color the progress
      bar: `barFormat: (bar) => chalk.blue(bar)`.
    @option opts {Number} percentLength the number of digits to include for percentages.  Should be above `3`.
     */

    PromiseBar.prototype.all = function(items, opts) {
      var progress, promise;
      if (opts == null) {
        opts = {};
      }
      if (!this.enabled) {
        return Promise.all(items);
      }
      this.clear();
      progress = new Progress(this, items, opts);
      if (this.items == null) {
        this.items = [];
      }
      this.items.push(progress);
      this.draw();
      promise = Promise.all(items);
      promise.PromiseBar = progress;
      return promise;
    };


    /*
    Sets up PromiseBar to manage stdout.  Until `enable()` is called, `PromiseBar.all()` acts like `Promise.all()`.
    Can be called multiple times without ill effect, as long as {PromiseBar#end} hasn't been called.
    @todo redraw on console resize
     */

    PromiseBar.prototype.enable = function() {
      var ansi;
      if (this.enabled) {
        return;
      }
      ansi = require("ansi");
      this.cursor = ansi(process.stdout);
      this.draw();
      this.bufferstdout();
      process.stdout.on("newline", (function(_this) {
        return function() {
          if (_this.processing || _this.ended) {
            return;
          }
          _this.clear();
          return _this.draw();
        };
      })(this));
      process.on("exit", (function(_this) {
        return function() {
          return _this.end();
        };
      })(this));
      return this.enabled = true;
    };


    /*
    Restore original stdout behavior, and prevent PromiseBar from trying changing the output.
     */

    PromiseBar.prototype.end = function() {
      var i, j, ref;
      if (this.ended) {
        return;
      }
      if (this.items && Array.isArray(this.items)) {
        this.processing = true;
        for (i = j = 0, ref = this.lines(); 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          this.cursor.down();
        }
      }
      return this.ended = true;
    };


    /*
    Removes all progress bars in stdout.  Assumes that the cursor is on the first line of the progress bars
    (under the blank line).  Returns the cursor to the starting position.
     */

    PromiseBar.prototype.clear = function() {
      var i, j, ref;
      if (this.ended) {
        return;
      }
      if (!(this.items && Array.isArray(this.items))) {
        return;
      }
      this.processing = true;
      for (i = j = 1, ref = this.lines(); 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        this.cursor.eraseLine().down();
      }
      this.cursor.up(this.lines());
      return this.processing = false;
    };


    /*
    Determine the maximum label length for progress bars.
    @param {Boolean} deep if `true`, check nested progress bars.  Defaults to `false`.
    @return {Number} the length of the longest label.
     */

    PromiseBar.prototype.maxLabelLength = function(deep) {
      var item, j, len, max, ref;
      if (deep == null) {
        deep = false;
      }
      max = 0;
      ref = this.items;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (item.rawLabel) {
          max = Math.max(item.indent.length + item.rawLabel.length, max);
        }
        if (deep) {
          max = Math.max(item.maxLabelLength(true), max);
        }
      }
      return max;
    };


    /*
    Draw the progress bars to stdout, including a blank line at the start.
     */

    PromiseBar.prototype.draw = function() {
      var item, j, len, ref;
      if (this.ended) {
        return;
      }
      if (!(this.items && Array.isArray(this.items))) {
        return;
      }
      this.processing = true;
      console.log("");
      ref = this.items;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        item.draw(this.maxLabelLength(true));
      }
      this.cursor.up(this.lines() + 1);
      return this.processing = false;
    };


    /*
    The number of lines of stdout that the progress bars take.
    @return {Number}
     */

    PromiseBar.prototype.lines = function() {
      return this.items.map(function(i) {
        return i.lines();
      }).reduce((function(a, b) {
        return a + b;
      }), 0);
    };


    /*
    PromiseBar needs stdout to print one line at a time.  Overwrites `process.stdout.write` to write strings that include
    `\n` into multiple writes.
     */

    PromiseBar.prototype.bufferstdout = function() {
      var write;
      write = process.stdout.write;
      return process.stdout.write = (function(_this) {
        return function() {
          var args, data, j, len, line, lines, results;
          data = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (typeof data !== "string" || _this.processing || _this.ended || data.indexOf("\n") === -1) {
            return write.apply(process.stdout, [data].concat(slice.call(args)));
          }
          lines = data.split("\n");
          if (data.slice(-1) === "\n") {
            lines = lines.slice(0, -1);
          }
          results = [];
          for (j = 0, len = lines.length; j < len; j++) {
            line = lines[j];
            results.push(write.apply(process.stdout, [line + "\n"].concat(slice.call(args))));
          }
          return results;
        };
      })(this);
    };

    return PromiseBar;

  })();

  bar = new PromiseBar();

  module.exports = bar;

}).call(this);
